Synapse Client-Server API
=========================

The following specification outlines how a client can send and receive data from 
a home server.

4/7/14 Grilling
---------------
- Mechanism for getting historical state changes (e.g. topic updates) - add 
  query param flag?
- Generic mechanism for linking first class events (e.g. feedback) with other 
  first class events (e.g. messages)?
- Generic mechanism for updating 'stuff about the room' (e.g. favourite coffee) 
  AND specifying clobbering rules (clobber/add to list/etc)?
- Makes no sense to paginate back on the event stream. We can also avoid having 
  event versions for EACH event, by having a start/end (similar
  to room list). When paginating back on rooms, just use the start event version 
  (so we don't need to know the event version of the message
  itself). Can possibily then standardise the response JSON for filtering.
- Scrap the dir=? Work through use cases where we absolutely need to know it.
- Specify an actual event ID for each event (to de-duplicate unknown event 
  types). Can do this inbound from other home servers on their PDU
  ID (e.g. event id = pduid@senderhshost)
- How to ensure a consistent view for clients paginating through room lists? 
  They aren't really ordered in any way, and if you're paginating
  through them, how can you show them a consistent result set? Temporary 'room 
  list versions' akin to event version? How does that work?


Terminology
-----------
eventver / ever : The version of an event sent by the server.
When using the event streaming API, each event has an associated version which 
should be persisted on the client. When reconnecting to the
event stream, this event version can be used to tell the server where the client 
got up to in the stream.

msgid : The ID of a message sent by a client in a room.
Clients send IMs to each other in rooms. Each IM sent by a client must have a 
unique message ID which is unique for that particular client.

userid : The user@host style ID of the client.
When registering for an account, the client specifies their username. The userid 
is this username along with the home servers unique
hostname. When federating between home servers, the userid is used to uniquely 
identify users across multiple home servers.

roomId : The roomid@host style ID for the room.
When rooms are created, the client either specifies or is allocated a room ID. 
This room ID must be used to send messages in that room.
Like with clients, there may be multiple rooms with the same ID across multiple 
home servers. The roomId is used to uniquely
identify a room when federating.

Global message ID : The globally unique ID for a message.
This ID is formed from the msgid, the client's synapseUserId and the 
synapseRoomId. This uniquely identifies any message. It is represented
with '-' as the delimeter between IDs. The globalMsgId is of the form: 
synapseRoomId-synapseUserId-msgid


REST API and the Event Stream
-----------------------------
Clients send data to the server via a RESTful API. They can receive data via 
this API or from an event stream. An event stream is a special path which 
streams all events the client may be interested in. This makes it easy to 
immediately receive updates from the REST API. All data is represented as JSON.

The Event Stream
----------------
Every event sent to the client has an event version ("ever") which must be 
persisted on the client. When the client next connects to the event stream, they 
should provide the last event ver they received from the server. This lets the 
server know where in the event stream the client is. These vers are completely 
opaque, and the client cannot infer anything from them.

  GET /events?from=$LAST_EVENT_VERSION
  Returns (success): A JSON array of Event Data.
  Returns (failure): An Error Response

LAST_EVENT_VERSION is the last event version obtained from Event Data. If the 
client is connecting for the first time and does not know any event versions,
they can use "START" to request all events from the start. For more information 
on this, see "Filtering Query Parameters".

Filtering Query Parameters
--------------------------
Clients may wish to filter results from the event stream, or other sources of 
information where the amount of information may be a problem,
e.g. in a room with 10,000s messages. The filtering query parameters provide a 
way to navigate a 'window' around a large set of data. These
parameters are only valid for GET requests.
       
        S e r v e r - s i d e   d a t a
 |-------------------------------------------------|
START      ^               ^                      END
           |_______________|
                   |
            Client-extraction

'START' and 'END' are magic values which specify the start and end of the 
dataset respectively.

Query parameters:
  from : $id - What item of data to start from. This could be a 0-based index, 
         an event version, or some other way of uniquely identifying data.
  to : $id - What item of data to end at. This could be a 0-based index, an 
       event version, or some other way of uniquely identifying data. Typically,
       clients will not know the item of data to end at, so this will usually be 
       START or END.
  limit : integer - An integer representing the maximum number of items to 
          return.
  dir : [f|b] - The direction to return results in. A direction of [f]orwards 
        would return the items at 'from' first, whereas [b]ackwards would
        return the items from 'to' first.
  search : NOT_YET_IMPLEMENTED : The search query to perform.

For example, the event stream has events E1 -> E15. The client wants the last 5 
events and doesn't know any previous events:

S                                                    E
|-E1-E2-E3-E4-E5-E6-E7-E8-E9-E10-E11-E12-E13-E14-E15-|
|                               |<---dir=backwards---|
|                          _____|   ___|             |
|__________________       |        |     ____________|
                   |      |        |     |
 GET /events?from=START&limit=5&dir=b&to=END
 Returns:
   E15,E14,E13,E12,E11


Another example: a public room list has rooms R1 -> R17. The client is showing 5 
rooms at a time on screen, and is on page 2. They want to
now show page 3 (rooms R11 -> 15):

S                                                           E
|  0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16 | index
|-R1-R2-R3-R4-R5-R6-R7-R8-R9-R10-R11-R12-R13-R14-R15-R16-R17| room
                  |____________| |________________|
                        |                |
                    Currently            |
                    viewing              |
                                         |
                         GET /rooms/list?from=9&to=END&dir=f&limit=5
                         Returns: R11,R12,R13,R14,R15


The term 'filtering query parameters' is used to describe an API which can be 
filtered in this way. The API will also specify what ID to use.
For example, the event streaming API is compatible with filtering query 
parameters with the id as the event version.

Unless specified, the default filtering parameters are from=START, to=END, 
dir=f, without a limit set. This allows you to hit an API like
/events without any query parameters to get everything.

Event Data
----------
This is a JSON object which looks like:
{
  "ever" : $EVENT_VERSION,
  "type" : $EVENT_TYPE,
  $URL_ARGS,
  "content" : {
    $EVENT_CONTENT
  }
}

Where:
  EVENT_VERSION = The opaque event version which can be used with 
                  /events?from=$LAST_EVENT_VERSION
  EVENT_TYPE = The namespaced event type (sy.*)
  URL_ARGS = Path specific data from the REST API
  EVENT_CONTENT = The event content 

Events are differentiated via the event type "type" key. This is the type of 
event being received. This can be expanded upon by using different namespaces. 
Every event MUST have a 'type' key.

Most events will have a corresponding REST URL. This URL will generally have 
data in it to represent the resource being modified,
e.g. /rooms/$roomid. The event data will contain extra top-level keys to expose 
this information to clients listening on an event
stream. The event content maps directly to the contents submitted via the REST 
API.

For example:
  Event Type: sy.example.room.members
  REST Path: /examples/room/$roomid/members/$userid
  REST Content: { "membership" : "invited" }
  
is represented in the event stream as:

{
  "ever" : "e_some_event_version",
  "type" : "sy.example.room.members",
  "roomid" : $roomid,
  "userid" : $userid,
  "content" : {
    "membership" : "invited"
  }
}

As convention, the URL variable arg "$varname" should map directly onto the name 
of the JSON key "varname".

Error Responses
---------------
If the client sends an invalid request, the server MAY respond with an error 
response. This is of the form:
{
  "error" : "string",
  "errcode" : integer
}
The 'error' string will be a human-readable error message. There may be 
additional keys depending on the error, but
the keys 'error' and 'errcode' will always be present.


Registration
============
Clients must register with the server in order to use the service. After 
registering, the client will be given an
access token which must be used in ALL requests as a query parameter 
'access_token'.

Registering for an account
--------------------------
  PUT /register
  With: A JSON object containing the key "user_id" which contains the desired 
        userid, or an empty JSON object to have the server allocate a userid 
        automatically.
  Returns (success): 200 OK with a JSON object:
                     {
                       "user_id" : "string [synapseUserId]",
                       "access_token" : "string"
                     }
  Returns (failure): An Error Response.
                     

Unregistering an account
------------------------
  PUT /unregister
  With query parameters: access_token=$ACCESS_TOKEN
  Returns (success): 200 OK
  Returns (failure): An Error Response.


========
REST API
========

All content must be application/json. Some keys are required, while others are 
optional. Unless otherwise specified,
all HTTP PUT/POST/DELETEs will return a 200 OK with an empty response body on 
success, and a 4xx/5xx with an optional Error Response on failure. When sending 
data, if there are no keys to send, an empty JSON object should be sent.

All POST/PUT/GET/DELETE requests MUST have an 'access_token' query parameter to 
allow the server to authenticate the client. All
POST requests MUST be submitted as application/json. 

Rooms
=====
A room is a conceptual place where users can send and receive messages. Rooms 
can be created, joined and left. Messages are sent
to a room, and all participants in that room will receive the message. Rooms are 
uniquely identified via the synapseRoomId.

Creating a room (with a room ID)
--------------------------------
  Event Type: sy.room.create
  REST Path: /rooms/$roomid
  Valid methods: PUT
  Required keys: None.
  Optional keys:
    visibility : [public|private] - Set whether this room shows up in the public 
    room list.
  Returns:
    On Failure: MAY return a suggested alternative room ID if this room ID is 
    taken.
    {
      suggested_roomid : $new_roomid
      error : "Room already in use."
      errcode : $errcode
    }

Creating a room (without a room ID)
-----------------------------------
  Event Type: sy.room.create
  REST Path: /rooms
  Valid methods: POST
  Required keys: None.
  Optional keys:
    visibility : [public|private] - Set whether this room shows up in the public 
    room list.
  Returns:
    On Success: The allocated room ID.
    {
      roomid : $roomid
    }

Setting the topic for a room
----------------------------
  Event Type: sy.room.topic
  REST Path: /rooms/$roomid/topic
  Valid methods: GET/PUT
  Required keys: 
    topic : $topicname - Set the topic to $topicname in room $roomid.


See a list of public rooms
--------------------------
  Event Type: sy.room.list
  REST Path: /rooms/list?filtering_query_parameters
  Valid methods: GET
  This API can use filtering query parameters, with the id as the 0-based start 
  index to start returning rooms from.
  Returns:
    {
      "rooms" : JSON array of RoomInfo JSON objects - Required.
      "total" : integer - Optional. The total number of rooms.
      "start" : integer - Optional. The 0-based index of the first room in 
      "rooms".
    }

RoomInfo: Information about a single room.
  Servers MUST send the key: roomid
  Servers MAY send the keys: topic, num_members
  {
    "roomid" : "string",
    "topic" : "string",
    "num_members" : integer
  }

Room Members
============

Invite/Joining/Leaving a room
-----------------------------
  Event Type: sy.room.members.state
  REST Path: /rooms/$roomid/members/$userid/state
  Valid methods: PUT/GET/DELETE
  Required keys:
    membership : [join|invite] - The membership state of $userid in room $roomid
                  join - Indicate you ($userid) are joining the room $roomid.
                  invite - Indicate that $userid has been invited to room 
                  $roomid.

  User $userid can leave room $roomid by DELETEing this path.

Checking the user list of a room
--------------------------------
  Event Type: sy.room.members.list
  REST Path: /rooms/$roomid/members/list
  Valid methods: GET
  Returns:
    A JSON object with room member userids as keys and their /members/$userid 
    content as the value. This will
    be nested for each path below /members/$userid. For example:
    {
      "$userid1" : {
                     "state" : { "membership" : "join" }
                   },
      "$userid2" : { "state" : { "membership" : "invite" } },
      "$userid3" : { "state" : { "membership" : "join" } },
    }

Messages
========
Users send messages to other users in rooms. These messages may be text, images, 
video, etc. Clients may also want to acknowledge messages by sending feedback, 
in the form of delivery/read receipts.

Server-attached keys
--------------------
The server MAY attach additional keys to messages and feedback. If a client 
submits keys with the same name, they will be clobbered by
the server.

Required keys:
  from : "string [userid]" - The userid of the user who sent the 
  message/feedback.
Optional keys:
  hsob_ts : integer - A timestamp (ms resolution) representing when the 
  message/feedback got to the sender's home server ("home server outbound 
  timestamp").
  hsib_ts : integer - A timestamp (ms resolution) representing when the 
  message/feedback got to the receiver's home server ("home server inbound 
  timestamp"). This may be the same as hsob_ts if the sender/receiver are on the 
  same home server.

Sending messages
----------------
  Event Type: sy.room.message
  REST Path: /rooms/$roomid/messages/$from/$msgid
  Valid methods: GET/PUT
  URL parameters:
    $from : userid - The sender's userid. This value will be clobbered by the 
    server before sending.
  Required keys: 
    msgtype: [sy.text|sy.emote|sy.image|sy.audio|sy.video|sy.location|sy.file] - 
             The type of message. Not to be confused with the Event 'type'.
  Optional keys:
    sender_ts : integer - A timestamp (ms resolution) representing the 
                wall-clock time when the message was sent from the client.
  Reserved keys:
    body : "string" - The human readable string for compatibility with clients 
           which cannot process a given msgtype. This key is optional, but
           if it is included, it MUST be human readable text 
           describing the message. See individual msgtypes for more 
           info on what this means in practice.

Each msgtype may have required fields of their own.

msgtype: sy.text
----------------
Required keys:
  body : "string" - The body of the message.
Optional keys:
  None.

msgtype: sy.emote
-----------------
Required keys:
  body : "string" - *tries to come up with a witty explanation*.
Optional keys:
  None.

msgtype: sy.image
-----------------
Required keys:
  url : "string" - The URL to the image.
Optional keys:
  body : "string" - info : JSON object (ImageInfo) - The image info for image 
         referred to in 'url'.
  thumbnail_url : "string" - The URL to the thumbnail.
  thumbnail_info : JSON object (ImageInfo) - The image info for the image 
                   referred to in 'thumbnail_url'.

ImageInfo: Information about an image.
{
  "size" : integer (size of image in bytes),
  "w" : integer (width of image in pixels),
  "h" : integer (height of image in pixels),
  "mimetype" : "string (e.g. image/jpeg)"
}

Interpretation of 'body' key: The alt text of the image, or some kind of content 
description for accessibility e.g. "image attachment".

msgtype: sy.audio
-----------------
Required keys:
  url : "string" - The URL to the audio.
Optional keys:
  info : JSON object (AudioInfo) - The audio info for the audio referred to in 
         'url'.

AudioInfo: Information about a piece of audio. 
{
  "mimetype" : "string (e.g. audio/aac)",
  "size" : integer (size of audio in bytes),
  "duration" : integer (duration of audio in milliseconds)
}

Interpretation of 'body' key: A description of the audio e.g. "Bee Gees - 
Stayin' Alive", or some kind of content description for accessibility e.g. 
"audio attachment".

msgtype: sy.video
-----------------
Required keys:
  url : "string" - The URL to the video.
Optional keys:
  info : JSON object (VideoInfo) - The video info for the video referred to in 
         'url'.

VideoInfo: Information about a video.
{
  "mimetype" : "string (e.g. video/mp4)",
  "size" : integer (size of video in bytes),
  "duration" : integer (duration of video in milliseconds),
  "w" : integer (width of video in pixels),
  "h" : integer (height of video in pixels),
  "thumbnail_url" : "string (URL to image)",
  "thumbanil_info" : JSON object (ImageInfo)
}

Interpretation of 'body' key: A description of the video e.g. "Gangnam style", 
or some kind of content description for accessibility e.g. "video attachment".

msgtype: sy.location
--------------------
Required keys:
  geo_uri : "string" - The geo URI representing the location.
Optional keys:
  thumbnail_url : "string" - The URL to a thumnail of the location being 
                  represented.
  thumbnail_info : JSON object (ImageInfo) - The image info for the image 
                   referred to in 'thumbnail_url'.

Interpretation of 'body' key: A description of the location e.g. "Big Ben, 
London, UK", or some kind of content description for accessibility e.g. 
"location attachment".


Sending feedback
----------------
When you receive a message, you may want to send delivery receipt to let the 
sender know that the message arrived. You may also
want to send a read receipt when the user has read the message. These receipts 
are collectively known as 'feedback'.

  Event Type: sy.room.message.feedback
  REST Path: /rooms/$roomid/messages/$msgfrom/$msgid/feedback/$from/$feedback
  Valid methods: GET/PUT
  URL parameters:
    $msgfrom - The sender of the message's userid.
    $from : userid - The sender of the feedback's userid. This value will be 
    clobbered by the server before sending.
    $feedback : [d|r] - Specify if this is a [d]elivery or [r]ead receipt.
  Required keys:
    None.
  Optional keys:
    sender_ts : integer - A timestamp (ms resolution) representing the 
    wall-clock time when the receipt was sent from the client.

Receiving messages (bulk/pagination)
------------------------------------
  Event Type: sy.room.message
  REST Path: /rooms/$roomid/messages/list
  Valid methods: GET
  Query Parameters:
    feedback : [true|false] - Specify if feedback should be bundled with each 
    message.
  This API can use filtering query parameters, with the id as the event ver of a 
  known message.
  Returns:
    A JSON array of Event Data. If the "feedback" parameter was set, this will 
    also contain a "feedback" key which
   contains a JSON array of feedback, with each element as Event Data with 
   compressed feedback for this message.

Event Data with compressed feedback is a special type of feedback with 
contextual keys removed. It is designed to limit the amount of redundant data 
being sent for feedback. This removes the type, room ID, message sender ID and 
message ID keys.

     ORIGINAL (via event streaming)
{
  "ever":"e1247632487",
  "type":"sy.room.message.feedback",
  "from":"string [userid]",
  "feedback":"string [d|r]",
  "roomid":"$roomid",
  "msgid":"$msgid",
  "msgfrom":"$msgfromid",
  "content":{
    "sender_ts":139880943
  }
}

     COMPRESSED (via /messages/list)
{
  "ever":"e1247632487",
  "from":"string [userid]",
  "feedback":"string [d|r]",
  "content":{
    "sender_ts":139880943
  }
}

When you join a room $roomid, you may want the last 10 messages with feedback. 
This is represented as:
  GET 
  /rooms/$roomid/messages/list?from=START&to=END&dir=b&limit=10&feedback=true

You may want to get 10 messages even earlier than that without feedback. If the 
last message had an event version of e12345678, this request would be:
  GET 
  /rooms/$roomid/messages/list?from=START&to=e12345678&dir=b&limit=10&
                               feedback=false
  
NOTE: Care must be taken when using this API in conjunction with event 
streaming. It is possible that this will return a message which will
      then come down the event stream, resulting in a duplicate message. Clients 
      should clobber based on the global message ID.

Examples
========

The following example is the story of "bob", who signs up at "sy.org" and joins 
the public room "room_beta@sy.org". They get the 2 most recent
messages (with feedback) in that room and then send a message in that room. 

For context, here is the complete chat log for room_beta@sy.org:

Room: "Hello world" (room_beta@sy.org)
Members: (2) alice@randomhost.org, friend_of_alice@randomhost.org
Messages:
  alice@randomhost.org : hi friend!                     
  [friend_of_alice@randomhost.org DELIVERED]
  alice@randomhost.org : you're my only friend          
  [friend_of_alice@randomhost.org DELIVERED]
  alice@randomhost.org : afk                            
  [friend_of_alice@randomhost.org DELIVERED]
  [ bob@sy.org joins ]
  bob@sy.org : Hi everyone
  [ alice@randomhost.org changes the topic to "FRIENDS ONLY" ]
  alice@randomhost.org : Hello!!!!
  alice@randomhost.org : Let's go to another room
  alice@randomhost.org : You're not my friend
  [ alice@randomhost.org invites bob@sy.org to the room 
  commoners@randomhost.org]


REGISTER FOR AN ACCOUNT
PUT: /register
Content: {}
Returns: { "userid" : "bob@sy.org" , "access_token" : "abcdef0123456789" }

GET PUBLIC ROOM LIST
GET: /rooms/list?access_token=abcdef0123456789
Returns: 
{ "total":3,
  "rooms":
  {
    { "roomid":"room_alpha@sy.org", "topic":"I am a fish" },
    { "roomid":"room_beta@sy.org", "topic":"Hello world" },
    { "roomid":"room_xyz@sy.org", "topic":"Goodbye cruel world" }
  }
}

JOIN ROOM room_beta@sy.org
PUT 
/rooms/room_beta%40sy.org/members/bob%40sy.org/state?
                                    access_token=abcdef0123456789
Content: { "membership" : "join" }
Returns: 200 OK

GET LATEST 2 MESSAGES WITH FEEDBACK
GET 
/rooms/room_beta%40sy.org/messages/list?from=START&to=END&dir=b&limit=2&
                                    feedback=true&access_token=abcdef0123456789
Returns:
[
  { 
    "ever":"01948374", 
    "type":"sy.room.message",
    "roomid":"room_beta@sy.org",
    "msgid":"avefifu",
    "from":"alice@randomhost.org",
    "hs_ts":139985736,
    "content":{
      "msgtype":"sy.text",
      "body":"afk"
    }
    "feedback": [
      {
        "ever":"e93742763",
        "from":"friend_of_alice@randomhost.org",
        "feedback":"d",
        "hs_ts":139985850,
        "content":{
          "sender_ts":139985843
        }
      }
    ]
  },
  { 
    "ever":"028dfe8373", 
    "type":"sy.room.message",
    "roomid":"room_beta@sy.org",
    "msgid":"afhgfff",
    "from":"alice@randomhost.org",
    "hs_ts":139970006,
    "content":{
      "msgtype":"sy.text",
      "body":"you're my only friend"
    }
    "feedback": [
      {
        "ever":"e93742763",
        "from":"friend_of_alice@randomhost.org",
        "feedback":"d",
        "hs_ts":139970144,
        "content":{
          "sender_ts":139970122
        }
      }
    ]
  },
]

SEND MESSAGE IN ROOM
PUT 
/rooms/room_beta%40sy.org/messages/bob%40sy.org/m0001?
                            access_token=abcdef0123456789
Content: { "msgtype" : "text" , "body" : "Hi everyone" }
Returns: 200 OK


Checking the event stream for this user:
GET: /events?from=START&access_token=abcdef0123456789
Returns:
[
  { 
    "ever":"e10f3d2b", 
    "type":"sy.room.members.state",
    "roomid":"room_beta@sy.org",
    "userid":"bob@sy.org",
    "content":{
      "membership":"join"
    }
  },
  { 
    "ever":"1b352d32", 
    "type":"sy.room.message",
    "roomid":"room_beta@sy.org",
    "msgid":"m0001",
    "from":"bob@sy.org",
    "hs_ts":140193857,
    "content":{
      "msgtype":"sy.text",
      "body":"Hi everyone"
    }
  }
]

Client disconnects for a while and the topic is updated in this room, 3 new 
messages arrive whilst offline, and bob is invited to another room.

GET /events?from=1b352d32&access_token=abcdef0123456789
Returns:
[
  { 
    "ever":"feee0294", 
    "type":"sy.room.topic",
    "roomid":"room_beta@sy.org",
    "from":"alice@randomhost.org",
    "content":{
      "topic":"FRIENDS ONLY",
    }
  },
  { 
    "ever":"a028bd9e", 
    "type":"sy.room.message",
    "roomid":"room_beta@sy.org",
    "msgid":"z839409",
    "from":"alice@randomhost.org",
    "hs_ts":140195000,
    "content":{
      "msgtype":"sy.text",
      "body":"Hello!!!"
    }
  },
  { 
    "ever":"49372d9e", 
    "type":"sy.room.message",
    "roomid":"room_beta@sy.org",
    "msgid":"z839410",
    "from":"alice@randomhost.org",
    "hs_ts":140196000,
    "content":{
      "msgtype":"sy.text",
      "body":"Let's go to another room"
    }
  },
  { 
    "ever":"10abdd01", 
    "type":"sy.room.message",
    "roomid":"room_beta@sy.org",
    "msgid":"z839411",
    "from":"alice@randomhost.org",
    "hs_ts":140197000,
    "content":{
      "msgtype":"sy.text",
      "body":"You're not my friend"
    }
  },
  { 
    "ever":"0018453d", 
    "type":"sy.room.members.state",
    "roomid":"commoners@randomhost.org",
    "from":"alice@randomhost.org",
    "userid":"bob@sy.org",
    "content":{
      "membership":"invite"
    }
  },
]



Outstanding problems / missing spec:
- No presence spec.
- Multiple devices on the same account (no shared way to auth e.g. we don't 
  msisdn auth)
- Spec out standard error responses (malformed json, missing keys, invalid 
  values for keys, unknown users (iff host is home server),
  room id in use, filter query param error / index out of bounds, )
- Spec out event streaming type (longpoll, long-lived)
- User level config/settings
- Push
- Typing notifications
- 'IM sync' API (fresh client, get last X msgs f.e room)
